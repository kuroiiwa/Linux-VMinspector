# vm\_inspector

## Test Cases
1. Allocating heap memory but not using it

From our tests, calling malloc without using the heap memory resulted in only one or two physical
frames being allocated, the rest of the virtual addresses were unmapped. 

This result makes sense because physical frames are only allocated as needed. 
In other words, even if data exists in the virtual address space, it will not be mapped
to a physical address until absolutely necessary.


2. Write-fault

We triggered a write fault by allocating heap memory (like in Test #1) and then initializing its 
data. After initialization, the page table shows up with many more page table entries (with their 
young bit, dirty bit, write bit and user bit set).

These bits are set by the CPU because the data was recently accessed and written to.


3. Read-fault followed by a write

We triggered a read fault by allocating heap memory and then accessing its uninitialized data.
After accessing, the page table gets populated with entries that have their young bit and user
bit set, while their dirty bit and write bit are unset.

This makes sense because the dirty bit is set when data has been modified, and the write bit is
set if the page is writable. Since we are only accessing data here, these bits remain unset.


4. Write (without fault)
In our test, the page table before non page-faulting writes is identical to the page table 
after the writes have occurred.

This makes sense because if a write doesn't trigger a page fault, then that data must
have already existed in a physical address, so the PTEs remain unchanged.

5. Copy-on-write
